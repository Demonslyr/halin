import React, { Component } from 'react';
import uuid from 'uuid';
import moment from 'moment';
import hoc from '../../higherOrderComponents';
import _ from 'lodash';
import Spinner from '../../Spinner';
import sentry from '../../sentry';
import queryLibrary from '../../data/query-library';
import { Grid, Breadcrumb, Dropdown, Message } from 'semantic-ui-react';
import { styler, Charts, ChartContainer, ChartRow, YAxis, LineChart } from 'react-timeseries-charts';
import timewindow from '../../timeseries/timewindow';
import unflatten from 'unflatten';
import Ring from 'ringjs';
import {
    TimeSeries,
    TimeRange,
    TimeEvent,
} from 'pondjs';

const RECORDS = 100;
const MAX_AGE = 2 * 1000;

class MetricsPane extends Component {
    state = {
        key: uuid.v4(),
        metrics: null,
        activeMetric: null,
        menu: {},
        observations: RECORDS,
    };

    componentDidMount() {
        return this.props.node.getAvailableMetrics()
            .then(metrics => {
                // Convert to the format that the dropdown menu wants.
                const metricOptions = _.sortBy(_.uniqBy(metrics.map(m => ({
                    key: m.name, text: m.name, value: m.name,
                })), 'key'), 'key');

                const flatMap = {};
                metricOptions.forEach(mo => flatMap[mo.key] = mo.key);

                const menu = unflatten(flatMap);
                console.log('Unflattened', this.menu);

                // Sorted and unique options
                this.setState({ metrics: metricOptions, menu });
            });
    }

    selectMetric = (event, data) => {
        console.log('event', event);
        console.log(data.value);

        const promise = this.getMetric(data.value);
        this.setState({
            activeMetric: data.value,
        });
        return promise;
    }

    haveCurrentMetricData(metric) {
        const data = this.state[metric];
        if (!data) { return false; }
        const lastObsTime = data[data.length - 1].t.getTime();
        const utcTimeNow = moment.utc().valueOf();

        if (utcTimeNow - lastObsTime < MAX_AGE) {
            return true;
        }

        sentry.fine(`Metric data for ${metric} aged out; ${moment.utc(lastObsTime).format()} vs. ${moment.utc(utcTimeNow).format()}`);
        return false;
    }

    getMetric(metric) {
        if (this.haveCurrentMetricData(metric)) {
            return Promise.resolve(this.state[metric]);
        }

        this.loading = true;

        return this.props.node.run(queryLibrary.GET_METRIC.query, { metric, last: this.state.observations })
            .then(data => data.records.map(r => ({
                t: new Date(r.get('t').toNumber()),
                value: r.get('value'),
            })).sort((a, b) => a.t - b.t)) // Keep sorted by date
            .catch(err => {
                sentry.reportError(`Failed to fetch metric ${metric}`, err);
                return [];
            })
            .then(data => {
                this.loading = false;
                this.setState({ [metric]: data });
                console.log('OBSERVATIONS', data.length);
                return data;
            });
    }

    render() {
        return (
            <div className='MetricsPane'>
                <Grid>
                    <Grid.Row columns={12}>
                        <Grid.Column width={4}>
                            <Dropdown placeholder='Neo4j Metric Name'
                                search selection
                                loading={_.isNil(this.state.metrics)}
                                allowAdditions={false}
                                upward={false}
                                onChange={this.selectMetric}
                                options={this.state.metrics} />

                            <Message info>Metrics are generated by the database and not sampled in real time.  For more information, 
                                see the <a href='https://neo4j.com/docs/operations-manual/current/monitoring/metrics/expose/#metrics-enable'>
                                Neo4j operations manual</a>
                            </Message>
                        </Grid.Column>
                        <Grid.Column width={8}>
                            {this.content()}
                        </Grid.Column>
                    </Grid.Row>
                </Grid>
            </div>
        )
    }

    getChartMin() {
        const data = this.state[this.state.activeMetric];
        return Math.min(...data.map(d => d.value));
    }

    getChartMax() {
        const data = this.state[this.state.activeMetric];
        return Math.max(...data.map(d => d.value));
    }

    getChartStart() {
        // Data is kept sorted.
        const arr = this.state[this.state.activeMetric];
        return arr[0].t.getTime();
    }

    getChartEnd() {
        // Data is kept sorted.
        const arr = this.state[this.state.activeMetric];
        return arr[arr.length - 1].t.getTime();
    }

    displayTimeRange() {
        const data = this.state[this.state.activeMetric];
        const timings = data.map(v => v.t.getTime());
        const startTime = Math.min(...timings);
        const endTime = Math.max(...timings);

        return timewindow.displayTimeRange(new TimeRange(new Date(startTime), new Date(endTime)));
    }

    content() {
        if (!this.state.activeMetric) {
            return <Message>Please select a metric from the drop-down above</Message>
        }

        if (this.state.activeMetric && this.loading) {
            return <Spinner active='true' />
        }

        console.log('metric juice', this.state.activeMetric, this.state);
        const displayColumns = [
            { Header: this.state.activeMetric, accessor: 'value' },
        ];

        const style = styler(displayColumns.map((col, idx) => ({
            key: col.accessor,
            color: '#000000',
            width: 3,
        })));

        const rawObservations = this.state[this.state.activeMetric];
        const ring = new Ring(rawObservations.length);
        this.dataSeries = new TimeSeries({
            name: 'Data Series',
            events: rawObservations.map(v => new TimeEvent(v.t, v.value)),
        });

        const dateFormat = 'MMMM Do YYYY, h:mm:ss a';
        const crumbs = this.state.activeMetric.split(/\./);

        return (
            <div className='content' style={{ paddingTop: '15px', paddingBottom: '15px' }}>
                <Grid>
                    <Grid.Row columns={1}>
                        <Breadcrumb size='large'>
                            {
                                crumbs.map((piece, idx) => 
                                    <span key={'bc-'+idx}>
                                        <Breadcrumb.Section active={idx === crumbs.length - 1}>{piece}</Breadcrumb.Section>
                                        { idx < crumbs.length - 1 ? <Breadcrumb.Divider icon='right chevron'/> : '' }
                                    </span>)
                            }
                        </Breadcrumb>
                    </Grid.Row>

                    <Grid.Row columns={1}>
                        <Grid.Column>
                            {/* <Legend type="swatch"
                                style={style}
                                categories={displayColumns.map((col, idx) => ({
                                    key: col.accessor,
                                    label: col.Header || col.accessor,
                                    style: { fill: '#000000' },
                                }))}
                            /> */}

                            {
                                <p>
                                    <strong>{moment.utc(this.getChartStart()).format(dateFormat)}</strong>
                                    &nbsp;-&nbsp;
                                    <strong>{moment.utc(this.getChartEnd()).format(dateFormat)}</strong>
                                </p>
                            }
                        </Grid.Column>
                    </Grid.Row>
                    <Grid.Row columns={1}>
                        <ChartContainer
                            showGrid={true}
                            showGridPosition='under'
                            // width='100%'
                            enablePanZoom={false}
                            timeAxisAngledLabels={true}
                            timeAxisHeight={65}
                            timeRange={this.displayTimeRange()}>
                            <ChartRow height="150">
                                <YAxis id="y"
                                    min={this.getChartMin()}
                                    max={this.getChartMax()}
                                    width="70"
                                    showGrid={true}
                                    type="linear" />
                                <Charts>
                                    {
                                        displayColumns.map((col, idx) =>
                                            <LineChart key={`ct-${idx}`}
                                                axis="y"
                                                style={style}
                                                columns={[col.accessor]}
                                                series={this.dataSeries}
                                            />
                                        )
                                    }
                                </Charts>
                            </ChartRow>
                        </ChartContainer>
                    </Grid.Row>
                </Grid>
            </div>
        );
    }
}

export default hoc.apocOnlyComponent(hoc.csvMetricsComponent(MetricsPane));